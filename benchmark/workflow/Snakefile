import os

# config file given when running snakemake
query_read_len = config["query_read_length"]
ref_seq_len = config["ref_seq_length"]
match_len = config["match_length"]
num_of_qseqs = config["num_of_qseqs"]
num_of_refseqs = config["num_of_refseqs"]
num_of_bins = config["num_of_bins"]

kmer_size = [12]
max_error = [0]
p_alphabet = ["murphy"]#["Dna4"]#["li"]

error_rates = [0.025] #[0, 0.025, 0.05, 0.075, 0.1]
bins = list(range(num_of_bins))
bin_ids = [str(x) for x in bins]
domains = ["nuc", "prot"]
blast_modes = ["blastX"]#["blastN", "tBlastN", "blastP"]

benchmark_file_names = ["lambda_index", "lambda_search", "lambda_sparse_index", "lambda_sparse_search", "iota"]

if not os.path.exists("benchmarks"):
    os.mkdir("benchmarks")

    for name in benchmark_file_names:
        path = "benchmarks/" + name + ".time"
        if "sparse" in path:
            with open(path, "w") as f:
                f.write("time\tmem\terror-code\tcommand\terror-rate\tblast-mode\tbin-id\n")
        else:
            with open(path, "w") as f:
                f.write("time\tmem\terror-code\tcommand\terror-rate\tblast-mode\n")

def getQueryDomain(wildcards):
    if wildcards.blast_mode == "blastN" or wildcards.blast_mode == "blastX":
        return "results/queries_nuc.fasta"
    else:
        return "results/queries_prot.fasta"

rule all:
    input:
        #prot = "results/queries_prot.fasta",
        #bins = expand("results/er_{er}/bins/bin_{bin_id}.fasta", bin_id=bin_ids, er=error_rates),
        #bin_paths = expand("results/er_{er}/{domain}/all_bin_paths.txt", er=error_rates, domain=domains),
        #ref_seqs = expand("results/er_{er}/{domain}/ref_seqs.fasta", er=error_rates, domain=domains),
        #iota = expand("results/er_{er}/{blast_mode}/iota/results.txt", er=error_rates, blast_mode=blast_modes)
        #lambda_combined = expand("results/er_{er}/{blast_mode}/lambda/search_out.m8", er=error_rates, blast_mode=blast_modes)
        trues = expand("results/er_{er}/{blast_mode}/benchmark/lambda_groundtruth.txt", er=error_rates, blast_mode=blast_modes),
        trues_iota = expand("results/er_{er}/{blast_mode}/benchmark/kmer{kmer}_error{error}_alphabet{alph}/iota_groundtruth.txt", er=error_rates, blast_mode=blast_modes, kmer=kmer_size, error=max_error, alph=p_alphabet),
        trues_iota_lambda = expand("results/er_{er}/{blast_mode}/benchmark/kmer{kmer}_error{error}_alphabet{alph}/iota_lambda.txt", er=error_rates, blast_mode=blast_modes, kmer=kmer_size, error=max_error, alph=p_alphabet),
        lambda_sparse = expand("results/er_{er}/{blast_mode}/lambda/sparse_out/kmer{kmer}_error{error}_alphabet{alph}/results.txt", er=error_rates, blast_mode=blast_modes, kmer=kmer_size, error=max_error, alph=p_alphabet)


include: "rules/simulate.smk"
include: "rules/iota.smk"
include: "rules/lambda.smk"
include: "rules/benchmark.smk"

